Т/З
1. Модель виртуального процессора:
class VirtualP
{
	/**
	* @param clockSignal тактовая частота виртуального процессора в единицу времени
	* @param algorithm алгоритм диспетчеризации
	* @param intensity интенсивность работы пользователя (0; 100) ->
	* -> @see интенсивность иcпользования PC можно взять из статистики, например,
	* http://www.bls.gov/news.release/ciuaw.nr0.htm, если установить критерий интенсивности как 
	* порядок запущеноагруженности приложений для  различных видов работ (работа с графикой > работа с web)
	* @param workingHours время работы эмулятора
	* @return  @timeMean среднее время ожидания пользователя
	* 
	*/
	int VirtualPStart(int clockSignal, String algorithm, float intensity, int workingHours);


}
2. Обобщенная модель процесса :

class Process
{
	/**
	* @param inSleep количество тактов для выполнения фоновых  операций
	* @param inWork цена(в тактах) работы приложения в активном режиме
	* @param popularityProbab вероятность того, что процесс будет запущен пользователем (0;100)
	* @anotation если пользователь запускает приложение в активный режим, а оно в следующий момент времени 
	*  не запускается, то считаем время простоя. Причем, если приложение до этого работало в фоновом режиме, то
	*  уходит меньше тактов на рабочий режим.
	* @param startPrice цена в тактах возобновления работы
	* @param priority приоритет процесса  от 1 до 10 (чем больше тем приоритетней)
	*/	
	Process(int inSleep, int inWork, int popularityProbab, int startPrice, int priority);

	sleep();
	work();
	/**
	* @param size количество информации которую, приложению надо считать
	* @param device откуда ее надо считать (от этого зависит сколько будет ждать приложение)
	*/
	read(int size, String device);
}

/*
При попытке запуска работающего процесса, цена его работы и сна будет увеличиваться. 
*/

3. Алгоритмы:
	- Циклическое планирование(не/приоритетное)
	- Несколько очередей
	- Лотерейное планирование

4. Мы это все реализовываем.

5. Затем, запускаем с различными исходными данными.

6. Анализируем. 

